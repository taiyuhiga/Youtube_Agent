import PptxGenJS from 'pptxgenjs';

// HTMLの要素タイプ
interface ParsedElement {
  type: 'text' | 'shape' | 'line' | 'icon' | 'background';
  content?: string;
  style?: Record<string, string>;
  position?: { x: number; y: number; w?: number; h?: number };
  attributes?: Record<string, string>;
}

// HTMLをパースしてPowerPointのネイティブ要素に変換
export class HtmlToPptxAdvancedConverter {
  private pptx: PptxGenJS;
  
  constructor() {
    this.pptx = new PptxGenJS();
    this.pptx.defineLayout({ name: 'LAYOUT_16x9', width: 10, height: 5.625 });
    this.pptx.layout = 'LAYOUT_16x9';
  }

  // HTMLからPPTXを生成（編集可能な要素として）
  async convertHtmlToPptx(htmlContent: string, title: string = 'プレゼンテーション'): Promise<ArrayBuffer> {
    // メタデータ設定
    this.pptx.author = 'AI Agent';
    this.pptx.company = 'Generated by AI';
    this.pptx.title = title;

    // HTMLをパース
    const parser = new DOMParser();
    const doc = parser.parseFromString(htmlContent, 'text/html');
    
    // スライドごとに処理
    const slides = this.extractSlides(doc);
    
    for (const slideHtml of slides) {
      const slide = this.pptx.addSlide();
      const elements = this.parseSlideElements(slideHtml);
      
      // 各要素をネイティブPowerPoint要素として追加
      for (const element of elements) {
        this.addElementToSlide(slide, element);
      }
    }

    // PPTXファイルを生成
    const pptxBlob = await this.pptx.write({ outputType: 'blob' }) as Blob;
    return await pptxBlob.arrayBuffer();
  }

  // スライドを抽出
  private extractSlides(doc: Document): Element[] {
    const slides = doc.querySelectorAll('.slide, .slide-container, section');
    if (slides.length === 0) {
      // スライドクラスがない場合はbody全体を1つのスライドとして扱う
      return [doc.body];
    }
    return Array.from(slides);
  }

  // スライド内の要素を解析
  private parseSlideElements(slideElement: Element): ParsedElement[] {
    const elements: ParsedElement[] = [];
    
    // 背景を解析
    const bgElement = this.parseBackground(slideElement);
    if (bgElement) {
      elements.push(bgElement);
    }
    
    // テキスト要素を解析（h1, h2, p等）
    const textElements = slideElement.querySelectorAll('h1, h2, h3, h4, h5, h6, p, span');
    textElements.forEach((el, index) => {
      const parsed = this.parseTextElement(el as HTMLElement, index);
      if (parsed) {
        elements.push(parsed);
      }
    });
    
    // SVG要素を解析
    const svgElements = slideElement.querySelectorAll('svg');
    svgElements.forEach((svg) => {
      const shapes = this.parseSvgElement(svg as SVGElement);
      elements.push(...shapes);
    });
    
    // アイコンを解析（Font Awesome等）
    const iconElements = slideElement.querySelectorAll('i.fas, i.fab, i.far');
    iconElements.forEach((icon, index) => {
      const parsed = this.parseIconElement(icon as HTMLElement, index);
      if (parsed) {
        elements.push(parsed);
      }
    });
    
    return elements;
  }

  // 背景を解析
  private parseBackground(element: Element): ParsedElement | null {
    const computedStyle = window.getComputedStyle(element);
    const background = computedStyle.background || computedStyle.backgroundColor;
    
    if (background && background !== 'none' && background !== 'transparent') {
      // グラデーション背景の場合
      if (background.includes('gradient')) {
        return {
          type: 'background',
          style: { background }
        };
      }
      // 単色背景の場合
      return {
        type: 'background',
        style: { backgroundColor: background }
      };
    }
    
    return null;
  }

  // テキスト要素を解析
  private parseTextElement(element: HTMLElement, index: number): ParsedElement | null {
    const text = element.textContent?.trim();
    if (!text) return null;
    
    const computedStyle = window.getComputedStyle(element);
    const rect = element.getBoundingClientRect();
    
    // 位置とサイズを10インチ幅のスライドに対する比率で計算
    const slideWidth = 10; // インチ
    const slideHeight = 5.625; // インチ
    const viewportWidth = window.innerWidth;
    const viewportHeight = viewportWidth * (9/16); // 16:9の比率
    
    return {
      type: 'text',
      content: text,
      style: {
        fontSize: computedStyle.fontSize,
        color: computedStyle.color,
        fontFamily: computedStyle.fontFamily,
        fontWeight: computedStyle.fontWeight,
        textAlign: computedStyle.textAlign,
      },
      position: {
        x: (rect.left / viewportWidth) * slideWidth,
        y: (rect.top / viewportHeight) * slideHeight,
        w: (rect.width / viewportWidth) * slideWidth,
        h: (rect.height / viewportHeight) * slideHeight,
      }
    };
  }

  // SVG要素を解析
  private parseSvgElement(svg: SVGElement): ParsedElement[] {
    const elements: ParsedElement[] = [];
    
    // 線要素を抽出
    const lines = svg.querySelectorAll('line');
    lines.forEach((line) => {
      const x1 = parseFloat(line.getAttribute('x1') || '0');
      const y1 = parseFloat(line.getAttribute('y1') || '0');
      const x2 = parseFloat(line.getAttribute('x2') || '0');
      const y2 = parseFloat(line.getAttribute('y2') || '0');
      
      elements.push({
        type: 'line',
        style: {
          stroke: line.getAttribute('stroke') || '#000000',
          strokeWidth: line.getAttribute('stroke-width') || '1',
        },
        position: {
          x: x1 / 128, // SVGの座標をスライドのインチに変換（仮の比率）
          y: y1 / 72,
          w: (x2 - x1) / 128,
          h: (y2 - y1) / 72,
        }
      });
    });
    
    // 円要素を抽出
    const circles = svg.querySelectorAll('circle');
    circles.forEach((circle) => {
      const cx = parseFloat(circle.getAttribute('cx') || '0');
      const cy = parseFloat(circle.getAttribute('cy') || '0');
      const r = parseFloat(circle.getAttribute('r') || '0');
      
      elements.push({
        type: 'shape',
        attributes: { shapeType: 'ellipse' },
        style: {
          fill: circle.getAttribute('fill') || '#000000',
        },
        position: {
          x: (cx - r) / 128,
          y: (cy - r) / 72,
          w: (r * 2) / 128,
          h: (r * 2) / 72,
        }
      });
    });
    
    return elements;
  }

  // アイコン要素を解析
  private parseIconElement(element: HTMLElement, index: number): ParsedElement | null {
    const rect = element.getBoundingClientRect();
    const computedStyle = window.getComputedStyle(element);
    
    // Font Awesomeのアイコンを図形で代替
    const iconClass = element.className;
    let shapeType = 'rect'; // デフォルト
    
    if (iconClass.includes('fa-brain')) {
      shapeType = 'cloud';
    } else if (iconClass.includes('fa-microchip')) {
      shapeType = 'rect';
    } else if (iconClass.includes('fa-robot')) {
      shapeType = 'octagon';
    }
    
    return {
      type: 'shape',
      attributes: { shapeType },
      style: {
        fill: computedStyle.color,
      },
      position: {
        x: (rect.left / window.innerWidth) * 10,
        y: (rect.top / (window.innerWidth * 9/16)) * 5.625,
        w: 0.5, // アイコンのサイズ
        h: 0.5,
      }
    };
  }

  // 要素をスライドに追加
  private addElementToSlide(slide: any, element: ParsedElement) {
    switch (element.type) {
      case 'background':
        // 背景の設定
        if (element.style?.backgroundColor) {
          slide.background = { color: this.rgbToHex(element.style.backgroundColor) };
        } else if (element.style?.background?.includes('gradient')) {
          // グラデーション背景（簡易実装）
          slide.background = { color: 'F0F8FF' }; // 代替色
        }
        break;
        
      case 'text':
        if (element.content && element.position) {
          const fontSize = parseInt(element.style?.fontSize || '12');
          const color = this.rgbToHex(element.style?.color || 'rgb(0,0,0)');
          
          slide.addText(element.content, {
            x: element.position.x || 0,
            y: element.position.y || 0,
            w: element.position.w || 3,
            h: element.position.h || 1,
            fontSize: Math.min(fontSize * 0.75, 96), // ポイントに変換
            color: color,
            fontFace: this.cleanFontFamily(element.style?.fontFamily || 'Arial'),
            bold: parseInt(element.style?.fontWeight || '400') >= 600,
            align: element.style?.textAlign || 'left',
          });
        }
        break;
        
      case 'shape':
        if (element.position) {
          const shapeType = element.attributes?.shapeType || 'rect';
          const fillColor = this.rgbToHex(element.style?.fill || 'rgb(0,0,0)');
          
          slide.addShape(shapeType, {
            x: element.position.x || 0,
            y: element.position.y || 0,
            w: element.position.w || 1,
            h: element.position.h || 1,
            fill: { color: fillColor },
          });
        }
        break;
        
      case 'line':
        if (element.position) {
          const lineColor = this.rgbToHex(element.style?.stroke || 'rgb(0,0,0)');
          const lineWidth = parseFloat(element.style?.strokeWidth || '1');
          
          slide.addShape('line', {
            x: element.position.x || 0,
            y: element.position.y || 0,
            w: element.position.w || 1,
            h: element.position.h || 0,
            line: { color: lineColor, width: lineWidth },
          });
        }
        break;
    }
  }

  // RGB色をHEXに変換
  private rgbToHex(rgb: string): string {
    // すでにHEX形式の場合
    if (rgb.startsWith('#')) {
      return rgb.substring(1);
    }
    
    // rgb(r, g, b)形式の場合
    const match = rgb.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
    if (match) {
      const r = parseInt(match[1]).toString(16).padStart(2, '0');
      const g = parseInt(match[2]).toString(16).padStart(2, '0');
      const b = parseInt(match[3]).toString(16).padStart(2, '0');
      return r + g + b;
    }
    
    // デフォルト色
    return '000000';
  }

  // フォントファミリーをクリーンアップ
  private cleanFontFamily(fontFamily: string): string {
    // 最初のフォントのみ取得し、引用符を削除
    const firstFont = fontFamily.split(',')[0].trim();
    return firstFont.replace(/['"]/g, '');
  }
} 